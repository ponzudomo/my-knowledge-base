このファイルでは、gitを扱う上で必要となる基本的な作業についてまとめておこうと思います。
git自体の解説やコマンドチートシートはまた別途作る予定です。

# 目次

> [gitでできる主な作業](#gitでできる主な作業)
> [各手順の詳しい解説]()
>  - []()
> [参考文献]

---

# gitでできる主な作業

gitでは、主に以下の流れで作業を行います。

```mermaid
graph TD
    A[リモートリポジトリ (GitHub)] <--> B(ローカルリポジトリ);

    subgraph ローカルでの作業
        B -- git clone / git pull --> C{作業ディレクトリ};
        C -- git add --> D[ステージングエリア];
        D -- git commit --> E[ローカルリポジトリの履歴];
        C -- git stash --> F((Stash: 一時退避));
        F -- git stash pop --> C;
    end

    subgraph リモートとの連携
        E -- git push --> A;
    end

    subgraph ブランチ操作
        E -- git branch --> G(新ブランチ);
        G -- git checkout --> C;
        G -- git merge / rebase --> E;
    end

    style A fill:#f9f,stroke:#333,stroke-width:2px
    style B fill:#ccf,stroke:#333,stroke-width:2px
```

---

# 各手順の詳しい解説

## 1. リモートの状態を取得する (`pull` vs `fetch` + `reset`)

リモートリポジトリの最新の変更をローカルに反映させたいとき、主に
- `pull`
- `fetch` + `reset`
の2つの方法があります。

それぞれの目的と挙動は大きく異なるため、状況に応じて正しく使い分けなければいけません。

---

## 1-1. `git pull` (日常的な更新)

`git pull` は、リモートの変更を取り込んで **「現在の自分の作業と統合する」** ためのコマンドです。

```bash
# developブランチにいる場合
git pull origin develop
```

### こんなときに使う
-   日々の開発で、他のメンバーが行った最新の変更を自分の作業ブランチに取り込みたいとき
-   自分のローカルでのコミット履歴を維持しながら、安全に更新したいとき

### 挙動
`git pull` は、内部的に2つのコマンドを連続して実行しています。
1.  `git fetch`: リモートの最新情報をローカルにダウンロード
2.  `git merge` (または `git rebase`): ダウンロードした変更を現在のローカルブランチに**マージ（統合）**

### 特徴
-   **ローカルの変更は保持される**: ローカルで行ったコミットは消えない　リモートの変更と統合される
-   **コンフリクトの可能性**: ローカルの変更とリモートの変更が同じ箇所を編集していた場合、コンフリクト（競合）が発生し手動での修正が必要になる
-   **マージコミットが作られる**: `merge`戦略の場合、統合の履歴として新しい「マージコミット」が自動的に作成されることがある

---

## 1-2. `git fetch` + `git reset --hard` (強制的な上書き)

`git fetch` と `git reset --hard` の組み合わせは、ローカルの状態を **「リモートの状態で完全に上書きする」** ための強力な方法です。

```bash
# 1. リモートの最新情報をダウンロード
git fetch origin

# 2. ローカルのdevelopブランチをリモートの状態で強制上書き
git reset --hard origin/develop
```

### こんなときに使う
-   ローカルの変更が不要になり、リモートの最新の状態にリセットしたいとき
-   ローカルで何か問題が発生し、一度クリーンな状態からやり直したいとき
-   「最新の状態を**まるごと**持ってきたい」とき

### 挙動
1.  `git fetch`: リモートの最新情報をローカルにダウンロード（ここまでは同じ）
2.  `git reset --hard <リモート名>/<ブランチ名>`: ローカルブランチの歴史と作業ディレクトリの状態を、ダウンロードしたリモートブランチの状態と**完全に一致**させる

### 特徴
-   **ローカルの変更はすべて破棄される**:
    -   コミットしていない変更（ステージングしたものも含む）は**完全に消える**
    -   ローカルにだけ存在したコミットも**完全に消える**
-   **コンフリクトは発生しない**: ローカルの状態を破棄して上書きするため、コンフリクトは起こりえない
-   **クリーンな状態になる**: ローカルリポジトリがリモートと全く同じ、クリーンな状態になる

> [!WARNING]
> この操作は非常に強力で、ローカルの変更が復元不可能な形で失われる可能性があります。
> 実行する前に、必要な変更がコミット＆プッシュされているか、あるいは `git stash` で退避されているか必ず確認してください。

---

## まとめ

|                    | `git pull`                     | `git fetch` + `git reset --hard` |
| :----------------- | :----------------------------- | :------------------------------- |
| **目的**           | 統合・マージ                   | 強制上書き・リセット             |
| **ローカルの変更** | **保持する**                   | **破棄する**                     |
| **安全性**         | 安全（コンフリクトは手動解決） | 危険（ローカルの変更が消える）   |
| **主な用途**       | 日常的な開発での更新           | ローカル環境の完全リセット       |

---

# 2. 変更を一時的に退避する (`git stash`)

作業の途中で、急に別のブランチに切り替える必要が出てしまった！でもまだコミットはしたくない...。
そんなときに使うのが `git stash` です。

これは、コミットしていない変更を一時的に「棚上げ」しておくための機能となります。

**こんなときに使う**
-   現在のブランチでの作業が中途半端だが、緊急の修正で別のブランチに移動する必要があるとき
-   `git pull` をする前に、コミットしていないローカルの変更を一時的に避けておきたいとき
-   クリーンな状態でテストを実行したいが、現在の変更は消したくないとき

## 2-1. `git stash` または `git stash save "メッセージ"`
-   **挙動**: 現在の作業ディレクトリの変更点（ステージング前後の変更）を `stack` と呼ばれる一時的な保管場所に退避させます。その後、作業ディレクトリは `HEAD` コミットの状態（クリーンな状態）に戻ります。
-   **特徴**: コミットを作成せずに作業内容を安全に保存できます。メッセージを付けることで、後から何の退避か分かりやすくすることもできます。

保管場所は `stash` ではなく `stack` となります。（字面が似ていてごっちゃになりますね...）
そうです、`queue` とか `stack` とかの `stack` です。
**`stash` で退避させた内容は新しい順でしか取り出せない** ので注意してください。

```bash
# 現在の変更を一時退避
git stash

# メッセージ付きで退避
git stash save "WIP: new feature implementation"
```

## 2-2. `git stash list`
-   **挙動**: 退避させた作業の一覧を表示します。
-   **特徴**: 複数の作業を `stash` した場合でも、どの退避が何なのかを確認できます。

```bash
# 退避させた作業の一覧を表示
git stash list
# 出力例:
# stash@{0}: WIP on develop: 6762db8 Add new feature
# stash@{1}: On master: WIP: new feature implementation
```

## 2-3. `git stash pop`
-   **挙動**: `stack` の一番上にある（＝最後に退避した）変更を現在のブランチに復元し、その退避データをスタックから**削除**します。
-   **特徴**: 最も一般的な復元方法。復元と削除を同時に行います。コンフリクトが発生する場合もあります。

```bash
# 最後に退避した作業を復元
git stash pop
```

## 2-4. `git stash apply`
-   **挙動**: `pop` と同様に一番上の変更を復元しますが、退避データは `stack` に**残したまま**にします。
-   **特徴**: 同じ退避内容を複数のブランチで使いたい場合などに便利です。

```bash
# 最後に退避した作業を復元（stackには残す）
git stash apply
```

## まとめ

| コマンド          | 目的                                   | スタックから削除 |
| :---------------- | :------------------------------------- | :--------------- |
| `git stash`       | 変更を一時保管場所に退避する           | -                |
| `git stash list`  | 退避した作業の一覧を見る               | -                |
| `git stash pop`   | 最新の退避を復元し、**削除する**       | **はい**         |
| `git stash apply` | 最新の退避を復元するが、**削除しない** | **いいえ**       |

---

# 3. 直前のコミットを修正する (`git commit --amend`)

>「あ、ファイルを入れ忘れた！」
>「コミットメッセージにタイポが...」

安心してください。
コミットした直後に、そのコミットに少しだけ変更を加えたい場合に使うのが `git commit --amend` です。

### こんなときに使う
-   直前のコミットにファイルを追加し忘れたとき
-   直前のコミットメッセージを修正したいとき
-   リモートにプッシュする前に、コミットを少しだけ手直ししたいとき

### 挙動
`git commit --amend` は、ステージングエリアにある変更を直前のコミットに含め、新しいコミットを作成して直前のコミットと**置き換え**ます。

```bash
# 1. 修正したいファイルや追加したいファイルをステージング
git add forgotten_file.txt

# 2. --amendオプションをつけてコミット
#    これにより、新しいコミットが作成され、直前のコミットは置き換えられる
git commit --amend

# メッセージだけを修正したい場合
git commit --amend -m "新しい正しいコミットメッセージ"
```

### 特徴
-   **コミット履歴が綺麗になる**: 不要な「修正コミット」(`fixup!`, `oops` など)を作らずに済みます。
-   **新しいコミットIDが生成される**: `amend`はコミットを「修正」するのではなく「置き換え」るため、コミットIDが変わります。

> [!WARNING]
> **リモートにプッシュ済みのコミットには `amend` を使わないでください。**
>
> 他の人がそのコミットを基に作業している可能性があるため、履歴を書き換えると深刻な問題を引き起こします。
> `amend` は、まだ自分のローカルにしかないコミットに対してのみ使用するのが原則です。

---

# 4. ブランチの歴史を整える (`merge` vs `rebase`)

フィーチャーブランチでの作業が完了し、メインブランチ（`main` や `develop`）に統合する際、主に `git merge` と `git rebase` の2つの方法があります。

## 4-1. `git merge` (履歴を正直に残す)

`merge` は、2つのブランチの歴史を合流させ、その事実を「マージコミット」として記録します。

```bash
# 1. mainブランチに移動
git checkout main

# 2. featureブランチをマージ
git merge feature/my-new-feature
```

-   **特徴**:
    -   **履歴が分岐・合流した事実がそのまま残る**ため、いつ何が統合されたか分かりやすい。
    -   ブランチの数が多いと、コミットログのグラフが複雑になりがち。
    -   安全で直感的な方法。

## 4-2. `git rebase` (履歴を一直線に整える)

`rebase` は、ブランチの分岐元を最新のコミットに「付け替え」て、コミット履歴を一直線に見せかけます。

```bash
# 1. フィーチャーブランチに移動
git checkout feature/my-new-feature

# 2. メインブランチの最新の変更の上に、自分の変更を再適用（リベース）
git rebase main
```

-   **特徴**:
    -   **コミット履歴が一直線になり、非常にクリーン**に見える。
    -   マージコミットが生成されない。
    -   コンフリクトがコミットごとに発生する可能性があり、解決が複雑になることがある。

> [!WARNING]
> **`merge` も`rebase` も他の人と共有しているブランチ（特に `main` や `develop`）に対して直接実行してはいけません。**
>
> 共有ブランチで使うと他の開発者の履歴と食い違い、混乱を招きます。
> まだpushしていないローカルのfeatureブランチを整理するために使うのが一般的です。

## まとめ

|                  | `git merge`                                  | `git rebase`                               |
| :--------------- | :------------------------------------------- | :----------------------------------------- |
| **目的**         | 履歴を正直に記録し、安全に統合する           | 履歴を一直線に整え、クリーンに保つ         |
| **コミット履歴** | 分岐と合流の履歴が**残る**（マージコミット） | 一直線になる（コミットが**作り直される**） |
| **安全性**       | 安全。チームでの共有ブランチに最適           | 危険。プッシュ済みの共有ブランチには使うな |
| **主な用途**     | 共有ブランチへの統合                         | プッシュ前のフィーチャーブランチの整理     |
